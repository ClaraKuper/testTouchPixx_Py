% Clear the workspace and the screen
sca;
close all;
clearvars;

% Here we call some default settings for setting up Psychtoolbox
AssertOpenGL;
PsychDefaultSetup(2);

rand('seed', sum(100 * clock));

screens = Screen('Screens');
screenNumber = max(screens);
white = WhiteIndex(screenNumber);
black = BlackIndex(screenNumber);

PsychImaging('PrepareConfiguration');
PsychImaging('AddTask', 'General', 'UseDataPixx');

[window, windowRect] = PsychImaging('OpenWindow', screenNumber, black);
[screenXpixels, screenYpixels] = Screen('WindowSize', window);
[xCenter, yCenter] = RectCenter(windowRect);
Screen('BlendFunction', window, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

winWidth = windowRect(3) - windowRect(1);
winHeight = windowRect(4) - windowRect(2);

dotColor = [1 0 0];
dotSizePix = 20;

% After OpenWindow so it's under the text generated by Screen
fprintf('\nTOUCHPixx Basic Demo\n');

% Configure DATAPixx/TOUCHPixx
Datapixx('SetVideoMode', 0);                        % Normal passthrough
Datapixx('EnableTouchpixx');                        % Turn on TOUCHPixx hardware driver
Datapixx('SetTouchpixxStabilizeDuration', 0.01);    % Stabilize inputs for calibration
Datapixx('RegWrRd');

% Put up first touch calibration target near top-left corner, and acquire TOUCHPixx coordinates
calDispX1 = 100;
calDispY1 = 100;
calCol = [255 255 255];
Screen('FillRect', window, calCol, [calDispX1-25 calDispY1-25 calDispX1+25 calDispY1+25]);
textCol = [0.5 0.5 0.5];
Screen('TextFont',window, 'Courier New');
Screen('TextSize',window, floor(50 * winWidth/1920));
DrawFormattedText(window, 'Touch center of first calibration square', 'center', 'center', textCol);
Screen('Flip', window);
touchPt = [0 0];                        % Wait for press
while touchPt == [0 0]
    Datapixx('RegWrRd');
    touchPt = Datapixx('GetTouchpixxCoordinates');
end;
calTouchX1 = touchPt(1);
calTouchY1 = touchPt(2);
Screen('Flip', window);

isPressed = 1;                          % Wait until panel release
while isPressed
    Datapixx('RegWrRd');
    status =  Datapixx('GetTouchpixxStatus');
    isPressed = status.isPressed;
end;

% Do same for a second calibration target near bottom-right corner of display
calDispX2 = winWidth - 100;
calDispY2 = winHeight - 100;
Screen('FillRect', window, calCol, [calDispX2-25 calDispY2-25 calDispX2+25 calDispY2+25]);
DrawFormattedText(window, 'Touch center of second calibration square', 'center', 'center', textCol);
Screen('Flip', window);
touchPt = [0 0];                        % Wait for press
while touchPt == [0 0]
    Datapixx('RegWrRd');
    touchPt = Datapixx('GetTouchpixxCoordinates');
end;
calTouchX2 = touchPt(1);
calTouchY2 = touchPt(2);
Screen('Flip', window);
isPressed = 1;                          % Wait until panel release
while isPressed
    Datapixx('RegWrRd');
    status =  Datapixx('GetTouchpixxStatus');
    isPressed = status.isPressed;
end;

% Calculate linear mapping between touch coordinates and display coordinates
mx = (calDispX2 - calDispX1) / (calTouchX2 - calTouchX1);
my = (calDispY2 - calDispY1) / (calTouchY2 - calTouchY1);
bx = (calTouchX1 * calDispX2 - calTouchX2 * calDispX1) / (calTouchX1 - calTouchX2);
by = (calTouchY1 * calDispY2 - calTouchY2 * calDispY1) / (calTouchY1 - calTouchY2);

% Calibrate TOUCHPixx
% Map each corner to a coordinate on the screen

% % paint a point in the upper left corner
% cal_tar_up_left = [windowRect(1), windowRect(2)];
% Screen('DrawDots', window, cal_tar_up_left, dotSizePix, dotColor, [], 2);
% Screen('Flip', window);
% touchPt_up_left = [0 0];
% t_now   = GetSecs;
% 
% while touchPt_up_left == [0 0]
%     Datapixx('RegWrRd');
%     touchPt_up_left = Datapixx('GetTouchpixxCoordinates');
% end

% % paint a point in the lower right corner
% cal_tar_low_right = [windowRect(3), windowRect(4)];
% Screen('DrawDots', window, cal_tar_low_right, dotSizePix, dotColor, [], 2);
% Screen('Flip', window);
% touchPt_low_right = [0 0];
% t_now   = GetSecs;
% 
% while touchPt_low_right == [0 0]
%     Datapixx('RegWrRd');
%     touchPt_low_right = Datapixx('GetTouchpixxCoordinates');
% end
% 
% calTouch_Coord = [0,0,touchPt_low_right(1),touchPt_low_right(2)]; %[touchPt_up_left(1),touchPt_up_left(2),touchPt_low_right(1),touchPt_low_right(2)];
% 
% transX = touchPt_low_right(1)/windowRect(3);
% transY = touchPt_low_right(2)/windowRect(4);

for dot = 1:5

    % Determine a random X and Y position for our dot. NOTE: As dot position is
    % randomised each time you run the script the output picture will show the
    % dot in a different position. Similarly, when you run the script the
    % position of the dot will be randomised each time. NOTE also, that if the
    % dot is drawn at the edge of the screen some of it might not be visible.
    dotXpos = rand * screenXpixels;
    dotYpos = rand * screenYpixels;
  
    Screen('DrawDots', window, [dotXpos dotYpos], dotSizePix, dotColor, [], 2);
    

    % Flip to the screen. This command basically draws all of our previous
    % commands onto the screen. See later demos in the animation section on more
    % timing details. And how to demos in this section on how to draw multiple
    % rects at once.
    % For help see: Screen Flip?
    Screen('Flip', window);

    % Now we have drawn to the screen we wait for a keyboard button press (any
    % key) to terminate the demo. For help see: help KbStrokeWait
    hit_target = false;
    t_now   = GetSecs;
    touchPt = [0 0];
    
    while ~ hit_target
        Datapixx('RegWrRd');
        touchPt = Datapixx('GetTouchpixxCoordinates');
        if ~ touchPt == [0 0]
            touch_X = mx*touchPt(1)+bx;
            touch_Y = my*touchPt(2)+by;
            if touch_X > dotXpos - 25 && touch_X < dotXpos + 25
                if touch_Y > dotYpos - 25 && touch_Y < dotYpos + 25
                    hit_target = true;
                end
            end
        end
    end;
    fprintf('\nThe Touched Coordinates are: %.3f and %.3f\n', touchPt(1),touchPt(2));
    fprintf('\nThe Printed Coordinates are: %.0f and %.0f\n', dotXpos,dotYpos);
    fprintf('\nThe Translated Coordinates are: %.3f and %.3f\n', mx*touchPt(1)+bx,my*touchPt(2)+by);
    Screen('Flip', window);
    WaitSecs(1)

end

% Clear the screen. "sca" is short hand for "Screen CloseAll". This clears
% all features related to PTB. Note: we leave the variables in the
% workspace so you can have a look at them if you want.
% For help see: help sca
sca;